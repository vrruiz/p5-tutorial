{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introducci\u00f3n a p5: Programaci\u00f3n gr\u00e1fica f\u00e1cil con Python Qu\u00e9 es p5 Processing es un entorno de programaci\u00f3n gr\u00e1fico, ideado por Ben Fry. Es, principalmente, una herramienta educativa. El objetivo es que personas sin conocimientos avanzados de inform\u00e1tica, especialmente artistas gr\u00e1ficos, se introdujeran en el mundo de la programaci\u00f3n, de una forma sencilla. En su encarnaci\u00f3n tradicional, Processing es un entorno integrado de desarrollo basado en Java, con librer\u00edas de f\u00e1cil uso. Processing ofrece funciones para dibujar y animar figuras geom\u00e9tricas, mostrar textos, im\u00e1genes, reproducir sonidos y v\u00eddeos e interactuar con algunos perif\u00e9ricos como teclado, rat\u00f3n y c\u00e1maras de v\u00eddeo. Estas librer\u00edas han sido adaptadas a otros lenguajes de programaci\u00f3n, como JavaScript y Python. Precisamente, p5py es la implementaci\u00f3n de Processing en Python nativo. \u00bfCu\u00e1les son las ventajas de p5 sobre Processing? La primera es Python, que es un lenguaje de m\u00e1s f\u00e1cil aprendizaje que Java. La segunda ventaja de p5 es que es una librer\u00eda nativa de Python , y por tanto, puede usarse con el resto de librer\u00edas de Python, como NumPy, Pandas, TensorFlow y mil m\u00e1s. Esto multiplica much\u00edsimo las posibilidades de p5. En este art\u00edculo de introducci\u00f3n Entorno de programaci\u00f3n Al ser Python est\u00e1ndar, p5 se puede programar usando cualquier entorno de programaci\u00f3n que tenga soporte de Python, como IDLE, Visual Studio Code, PyCharm, etc. Actualmente, en la Raspberry Pi viene el entorno Thonny Python IDE, que es el que usaremos en este tutorial. Al final del art\u00edculo indicamos los pasos a seguir para instalar las librer\u00edas p5. Vamos a ver ahora c\u00f3mo programar. Hola mundo, vesi\u00f3n p5 Este es el programa m\u00e1s b\u00e1sico que podemos hacer usando p5. Tan b\u00e1sico que lo \u00fanico que hace es abrir una ventana. Los comentarios se indican con una almohadilla. 1 2 3 4 5 6 7 8 9 from p5 import * # Usar las funciones de p5 def setup (): # Inicializaci\u00f3n size ( 300 , 300 ) # Ventana de 300x300 p\u00edxeles def draw (): # Dibujar pass # No hacer nada run () # Ejecutar p5 Lo que hace run() es llamar una sola vez a la funci\u00f3n setup() . Luego, entra en un bucle infinito en el que se llamada a la funci\u00f3n draw() 60 veces cada segundo. Generalmente, querremos hacer m\u00e1s cosas. Vamos a hacer un ejemplo m\u00e1s interesante. El siguiente programa crea una ventana de 500 p\u00edxeles de largo 500 p\u00edxeles de ancho y selecciona el color blanco para los trazos. Luego entra en un bucle infinito que pinta el fondo de la ventana de gris y dibuja una l\u00ednea desde el centro de la ventana hasta la posici\u00f3n actual del cursor del rat\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 from p5 import * # Usar las funciones de p5 def setup (): # Inicializaci\u00f3n size ( 300 , 300 ) # Establecer tama\u00f1o de la ventana stroke ( 255 , 255 , 255 ) # Trazos de color blanco def draw (): # Dibujar background ( 127 , 127 , 127 ) # Fondo gris line ( 150 , 150 , mouse_x , mouse_y ) # L\u00ednea desde centro al rat\u00f3n run () # Ejecutar programa Ahora usamos varias funciones de dibujo: stroke(color) . Establecer el color de los trazos. background(color) . Rellenar el fondo de la ventana. line(x_inicial, y_inicial, x_final, y_final) . Dibujamos una l\u00ednea. Tambi\u00e9n usamos un par de variables globales: mouse_x , mouse_y . Son variables proporcionadas por p5 que nos devuelven la posici\u00f3n actual del puntero del rat\u00f3n sobre la ventana. Por supuesto, p5 ofrece muchas m\u00e1s funciones y variables para dibujar otras figuras, trabajar con colores o leer otros perif\u00e9ricos. Pero por muy complicados que los hagamos, todos los programas de p5 tienen exactamente la misma estructura: import , setup() , draw() y run() . \u00a1Es muy f\u00e1cil! Coordenadas Para dibujar en Processing se har\u00e1 un uso frecuente de las coordenadas de la ventana. Su tama\u00f1o se define en la funci\u00f3n setup() mediante size(ancho,largo) . Para dibujar, debemos tener en cuenta que el punto x = 0, y = 0 est\u00e1 situado en la esquina superior derecha. x,y x,y x,y (0,0) (1,0) (2,0) (0,1) (1,1) (2,1) (0,2) (1,2) (2,2) En p5, podemos conocer el ancho y largo de la ventana actual, definidos en size, mediante dos variables globales. height . Ancho de la ventana. width . Largo de la ventana. As\u00ed, para dibujar una l\u00ednea desde el centro de la ventana a all\u00e1 donde est\u00e9 el cursor del rat\u00f3n har\u00edamos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from p5 import * # Usar funciones de p5 def setup (): # Inicializaci\u00f3n size ( 300 , 300 ) # Define tama\u00f1o de la ventana stroke ( 0 , 0 , 0 ) # Trazo negro def draw (): # Dibujar background ( 255 , 255 , 255 ) # Fondo blanco centro_x = height / 2 # Calcula mitad de la ventana centro_y = width / 2 # Calcula mitad de la ventana line ( centro_x , # Dibujar l\u00ednea desde el centro centro_y , # de la ventana hasta cursor rat\u00f3n. mouse_x , # Coordenada x del rat\u00f3n mouse_y ) # Coordenada y del rat\u00f3n run () # Ejecutar programa El programa es bastante similar al anterior, pero en este caso, las coordenadas del centro de la ventana se calculan autom\u00e1ticamente. Colores A la hora de dibujar, muchas veces deberemos especificar un color. Aunque no sea expl\u00edcito, las figuras necesitan al menos el color del trazo, pero muchas veces tambi\u00e9n el relleno. Y hay varias formas de especificar los colores. Escala de gris, de 0 a 255 . Representa un color en la escala de grises, desde el negro (0) al blanco (255). Rojo, verde, azul . En este caso, indicamos tres valores, tambi\u00e9n desde el 0 al 255, pero indicando el tono de rojo, verde y azul. Rojo, verde, azul, transparencia . Opcionalmente, podemos indicar un cuarto valor, el de la transparencia, tambi\u00e9n desde 0 (completamente transparente) a 255 (opaco). Esto nos permite combinar figuras y mezclar colores. Veamos algunos ejemplos de uso: 1 2 3 background ( 255 ) # Fondo blanco background ( 255 , 0 , 0 ) # Fondo rojo background ( 0 , 0 , 255 , 127 ) # Fondo azul, semi-transparente Antes dibujamos una l\u00ednea, \u00bfd\u00f3nde especifiacamos el color de su trazo? Hay dos funciones que debemos llamar antes para indicar los colores tanto el trazo como del relleno de las figuras. stroke(color) . Define el color del trazo. no_stroke() . Dibuja la figura sin trazos. fill(color) . Relleno de la figura. Se aplica en cuadrados, rect\u00e1ngulos o elipses. no_fill() . Dibuja la figura sin color de relleno. Por ejemplo, para dibujar un rect\u00e1ngulo con trazo blanco y relleno verde: 1 2 3 stroke ( 255 ) # Trazo blanco fill ( 0 , 255 , 0 ) # Relleno verde rect ( 25 , 25 , 75 , 75 ) # Dibujar rect\u00e1ngulo Estas funciones se pueden encadenar para dibujar varias figuras con diferentes colores. 1 2 3 4 5 stroke ( 127 , 5 , 38 ) # Trazo de color no_fill () # Sin relleno rect ( 10 , 10 , 90 , 90 ) # Dibujar rect\u00e1ngulo fill ( 255 , 0 , 0 , 127 ) # Relleno rojo semi-transparente rect ( 20 , 20 , 80 , 80 ) # Otro rect\u00e1ngulo Figuras b\u00e1sicas Bueno, aunque ya hemos visto c\u00f3mo usar dos figuras en p5, vamos a poner aqu\u00ed otras m\u00e1s: point(x,y) . Dibuja un punto con el trazo especificado por stroke() . line(x_inicial, y_inicial, x_final, y_final) . Dibuja una l\u00ednea desde las coordenadas iniciales a las coordenadas finales. Usa el color de trazo especificado por stroke() . triangle(x_1, y_1, x_2, y_2, x_3, y_3) . Dibuja un tri\u00e1ngulo definido por tres coordenadas. Color de trazo especificado por stroke() y relleno por fill() . square(x, y, lado) . Dibuja un cuadrado de tama\u00f1o lado en las coordenadas indicadas. Color de trazo especificado por stroke() y relleno por fill() . rect(x, y, largo, ancho) . Dibuja un rect\u00e1ngulo desde las coordenadas iniciales a las coordenadas. Color de trazo especificado por stroke() y relleno por fill() . circle(x, y, radio) . Dibuja un c\u00edrculo con centro en las coordenadas x,y y con el radio especificado. Color de trazo especificado por stroke() y relleno por fill() . ellipse(x, y, largo, ancho) . Dibuja una elipse con centro en las coordenadas x,y y con el ancho y largo especificados. Color de trazo especificado por stroke() y relleno por fill() . Todos los par\u00e1metros indicados (coordenadas, radios, tama\u00f1os) son num\u00e9ricos, generalmente n\u00fameros naturales. Textos Processing, y p5, tambi\u00e9n permiten escribir textos. Para ello se usa la funci\u00f3n text() . text(texto, x, y) . Escribe el texto en las coordenadas x,y con el color de trazo especificado por stroke() . Tambi\u00e9n es posibile indicar el tama\u00f1o. text_size(tama\u00f1o) . Cambiar el tama\u00f1o del texto, medido en p\u00edxeles. Actualmente, para usar la funci\u00f3n text_size() , p5 requiere usar una fuente vectorial. Uno de los formatos m\u00e1s populares para tipograf\u00edas vectoriales es TTF (TrueType Font) y los sistemas operativos suelen venir con estos ficheros. Adem\u00e1s, hay fuentes libres de derechos que se pueden descargar desde Internet. En nuestro ejemplo, usamos una fuente disponible en Linux. create_font(fichero) . Fichero debe ser la ruta y el nombre del fichero con la tipograf\u00eda vectorial a utilizar. Devuelve un valor de tipo PFont (fuente de Processing). Este valor hay que usarlo para establecer la fuente predefinida. text_font(fuente) . Establece la fuente por defecto. El par\u00e1metro fuente debe ser del tipo PFont. Ahora veamos un ejemplo de uso de textos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from p5 import * # Usar funciones de p5 def setup (): # Inicializaci\u00f3n size ( 300 , 300 ) # Establecer tama\u00f1o de la ventana fuente = create_font ( 'DejaVuSans.ttf' ) # Usar fuente text_font ( fuente ) # Esteblecer fuente predefinida def draw (): background ( 0 ) # Fondo negro stroke ( 255 ) # Trazo blanco text_size ( 20 ) # Tama\u00f1o de texto text ( \"Hola mundo\" , 0 , 0 ) # Escribe texto run () # Ejecutar programa Interacci\u00f3n Para reaccionar a acciones realizadas por los usuarios, los programas con interfaz gr\u00e1fico deben leer los estados y eventos del teclado y rat\u00f3n. p5 no es menos, y lo hace bastante sencillo. Rat\u00f3n Como hemos visto, podemos conocer las coordenadas del rat\u00f3n, pero no son las \u00fanicas variables disponibles. Tambi\u00e9n es posible detectar si se han pulsado los botones: mouse_x . Coordenada x del rat\u00f3n. mouse_y . Coordenada y del rat\u00f3n. mouse_is_pressed . Verdadero si se ha pulsado un bot\u00f3n del rat\u00f3n. mouse_button . Si mouse_is_pressed es verdadero, mouse_button tendr\u00e1 el valor LEFT o RIGHT seg\u00fan el bot\u00f3n del rat\u00f3n que se ha presionado (izquierdo, derecho). Vamos a ver c\u00f3mo cambiar el fondo de la pantalla seg\u00fan est\u00e9 pulsado o no el bot\u00f3n del rat\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from p5 import * # Usar funciones de p5 def setup (): size ( 300 , 300 ) # Tama\u00f1o de la ventana def draw (): if mouse_is_pressed == True : # Si se ha presionado el bot\u00f3n del rat\u00f3n if mouse_button == 'LEFT' : # y el bot\u00f3n es el izquierdo background ( 255 ) # mostrar el fondo en blanco else : # pero si es el bot\u00f3n derech background ( 127 ) # mostrar el fondo en gris. else : # Si no se ha presionado el rat\u00f3n background ( 0 ) # mostrar el fondo de color negro. run () # Ejecutar programa Teclado La l\u00f3gica del teclado es similar a la del rat\u00f3n. Hay funciones para saber si se ha pulsado alguna tecla y otra para saber qu\u00e9 tecla ha sido. key_is_pressed . Es verdadero si hay una tecla pulsada. key . Da el valor de la tecla. Si son caracteres normales, nos da su valor (por ejemplo a , '\u00d1' o \u20ac ). Pero tambi\u00e9n nos indica si se ha pulsado alguna tecla especial. Los valores de teclas especiales son: UP (flecha arriba), DOWN (flecha abajo), LEFT (flecha izquierda), RIGHT (flecha derecha), PAGEUP (p\u00e1gina arriba), PAGEDOWN (p\u00e1gina abajo), RETURN (retorno), ENTER , ESC (escape), DELETE (suprimir), TAB (tabulador), BACKSPACE (borrar), SHIFT (may\u00fascula), ALT , CONTROL , F1 ... F12 (teclas de funci\u00f3n), HOME (inicio), END (fin). Vamos a dibujar por la pantalla usando las flechas del teclado: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from p5 import * # Usar funciones de p5 cursor_x = 0 # Variables globales para almacenar cursor_y = 0 # la posici\u00f3n actual del cursor camino = [] # Lista para camino recorrido def setup (): # Inicializaci\u00f3n global cursor_x , cursor_y # Usar las variables globales size ( 300 , 300 ) # Tama\u00f1o de la ventana cursor_x = height / 2 # Posici\u00f3n inicial para comenzar cursor_y = width / 2 # a pintar: centro de ventana stroke ( 0 ) # Trazo negro def draw (): # Dibujar global cursor_x , cursor_y # Usar las variables globales global camino # Usar las variables globales background ( 255 ) # Aqu\u00ed para no borrar la ventana if key_is_pressed == True : # \u00bfSe ha presionado una tecla? pos = ( cursor_x , cursor_y ) # Almacenar posici\u00f3n actual en tupla camino . append ( pos ) # Guardar tupla en lista print ( len ( camino )) if key == 'LEFT' : # Flecha izquierda cursor_x = cursor_x - 1 # ir a la izquierda elif key == 'RIGHT' : # Flecha derecha cursor_x = cursor_x + 1 # ir a la derecha elif key == 'UP' : # Flecha arriba cursor_y = cursor_y - 1 # ir arriba elif key == 'DOWN' : # Flecha abajo cursor_y = cursor_y + 1 # ir abajo for punto in camino : # Dibujar camino ya realizado x = punto [ 0 ] # Obtener coordenada x del punto y = punto [ 1 ] # Obtener coordenada y del punto point ( x , y ) # Dibujar punto point ( cursor_x , cursor_y ) # Dibujar punto en posici\u00f3n actual run () C\u00f3mo instalar p5 en Linux Debian, Ubuntu, Raspberry Pi OS De momento, p5py no est\u00e1 empaquetado en Debian, lo que significa que tampoco est\u00e1 disponible en las distribuciones derivadas como Ubuntu y Raspberry Pi OS. Lo primero que hay que hacer es asegurarse de que el paquete python3-pil no est\u00e1 instalado, dado que entra en conflicto con otras librer\u00edas que p5 necesita instalar. 1 $ sudo apt-get remove python3-pil <!-- Los siguientes paquetes se ELIMINAR\u00c1N: hplip mu-editor python3-guizero python3-pil python3-pil.imagetk python3-reportlab python3-sense-emu python3-sense-hat sense-emu-tools sense-hat libf77blas.so.3: cannot open shared file: no such file or directory sudo apt-get install libatlas-base-dev RuntimeError: Could not import backend \"Glfw\" sudo apt install libglfw3 OpenGL.error.NullFunctionError: Attempt to call an undefined function gluNewTess, check for bool(gluNewTess) before calling apt-get install freeglut3-dev --> A continuaci\u00f3n, instalamos algunas librer\u00edas necesarias: 1 2 $ sudo apt-get install libjpeg-dev libfreetype6 libfreetype6-dev \\ zlib1g-dev libatlas-base-dev libglfw3 freeglut3-dev Y finalmente, instalamos p5: 1 $ pip3 install p5 Fedora Primero hay que instalar las dependencias 1 $ sudo dnf install glfw Y finalmente, instalamos p5: 1 $ pip3 install p5 Problemas conocidos Processing, el original, es un proyecto maduro mientras que p5 a\u00fan est\u00e1 en desarrollo activo. Algunos de los problemas que he encontrado hasta ahora son: Para finalizar la ejecuci\u00f3n de un programa de p5 en Thonny, tras cerrar la ventana hay que parar la ejecuci\u00f3n de la tarea de forma manual. Algo similar ocurre en Python IDLE y probablemente en otros entornos integrados. Actualmente no se puede modificar el tama\u00f1o del tipo de letra predefinida, hay que usar una tipograf\u00eda vectorial. Las funciones de dibujo no se ejecutan en setup() , solo en draw() . En el ejemplo de uso del teclado, las llamadas a point() en el bucle son muy lentas. Eso hace que el retardo en responder al teclado se vaya acumulando seg\u00fan hay m\u00e1s puntos. Conclusiones p5 ofrece unas librer\u00edas gr\u00e1ficas reconocidas por su facilidad de uso. Sin embargo, su versi\u00f3n actual (0.7.3) no est\u00e1 exenta de peque\u00f1os problemas y no ofrece el mismo rendimiento que Processing en otros lenguajes, como Java o JavaScript. Es posible que en futuras versiones estos problemas se arreglen y la experiencia de uso sea mucho m\u00e1s satisfactoria. Enlaces Documentaci\u00f3n de p5 . Referencia de funciones . P\u00e1gina de desarrollo de p5 . Processing . Tutorial de Python .","title":"Home"},{"location":"#introduccion-a-p5-programacion-grafica-facil-con-python","text":"","title":"Introducci\u00f3n a p5: Programaci\u00f3n gr\u00e1fica f\u00e1cil con Python"},{"location":"#que-es-p5","text":"Processing es un entorno de programaci\u00f3n gr\u00e1fico, ideado por Ben Fry. Es, principalmente, una herramienta educativa. El objetivo es que personas sin conocimientos avanzados de inform\u00e1tica, especialmente artistas gr\u00e1ficos, se introdujeran en el mundo de la programaci\u00f3n, de una forma sencilla. En su encarnaci\u00f3n tradicional, Processing es un entorno integrado de desarrollo basado en Java, con librer\u00edas de f\u00e1cil uso. Processing ofrece funciones para dibujar y animar figuras geom\u00e9tricas, mostrar textos, im\u00e1genes, reproducir sonidos y v\u00eddeos e interactuar con algunos perif\u00e9ricos como teclado, rat\u00f3n y c\u00e1maras de v\u00eddeo. Estas librer\u00edas han sido adaptadas a otros lenguajes de programaci\u00f3n, como JavaScript y Python. Precisamente, p5py es la implementaci\u00f3n de Processing en Python nativo. \u00bfCu\u00e1les son las ventajas de p5 sobre Processing? La primera es Python, que es un lenguaje de m\u00e1s f\u00e1cil aprendizaje que Java. La segunda ventaja de p5 es que es una librer\u00eda nativa de Python , y por tanto, puede usarse con el resto de librer\u00edas de Python, como NumPy, Pandas, TensorFlow y mil m\u00e1s. Esto multiplica much\u00edsimo las posibilidades de p5. En este art\u00edculo de introducci\u00f3n","title":"Qu\u00e9 es p5"},{"location":"#entorno-de-programacion","text":"Al ser Python est\u00e1ndar, p5 se puede programar usando cualquier entorno de programaci\u00f3n que tenga soporte de Python, como IDLE, Visual Studio Code, PyCharm, etc. Actualmente, en la Raspberry Pi viene el entorno Thonny Python IDE, que es el que usaremos en este tutorial. Al final del art\u00edculo indicamos los pasos a seguir para instalar las librer\u00edas p5. Vamos a ver ahora c\u00f3mo programar.","title":"Entorno de programaci\u00f3n"},{"location":"#hola-mundo-vesion-p5","text":"Este es el programa m\u00e1s b\u00e1sico que podemos hacer usando p5. Tan b\u00e1sico que lo \u00fanico que hace es abrir una ventana. Los comentarios se indican con una almohadilla. 1 2 3 4 5 6 7 8 9 from p5 import * # Usar las funciones de p5 def setup (): # Inicializaci\u00f3n size ( 300 , 300 ) # Ventana de 300x300 p\u00edxeles def draw (): # Dibujar pass # No hacer nada run () # Ejecutar p5 Lo que hace run() es llamar una sola vez a la funci\u00f3n setup() . Luego, entra en un bucle infinito en el que se llamada a la funci\u00f3n draw() 60 veces cada segundo. Generalmente, querremos hacer m\u00e1s cosas. Vamos a hacer un ejemplo m\u00e1s interesante. El siguiente programa crea una ventana de 500 p\u00edxeles de largo 500 p\u00edxeles de ancho y selecciona el color blanco para los trazos. Luego entra en un bucle infinito que pinta el fondo de la ventana de gris y dibuja una l\u00ednea desde el centro de la ventana hasta la posici\u00f3n actual del cursor del rat\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 from p5 import * # Usar las funciones de p5 def setup (): # Inicializaci\u00f3n size ( 300 , 300 ) # Establecer tama\u00f1o de la ventana stroke ( 255 , 255 , 255 ) # Trazos de color blanco def draw (): # Dibujar background ( 127 , 127 , 127 ) # Fondo gris line ( 150 , 150 , mouse_x , mouse_y ) # L\u00ednea desde centro al rat\u00f3n run () # Ejecutar programa Ahora usamos varias funciones de dibujo: stroke(color) . Establecer el color de los trazos. background(color) . Rellenar el fondo de la ventana. line(x_inicial, y_inicial, x_final, y_final) . Dibujamos una l\u00ednea. Tambi\u00e9n usamos un par de variables globales: mouse_x , mouse_y . Son variables proporcionadas por p5 que nos devuelven la posici\u00f3n actual del puntero del rat\u00f3n sobre la ventana. Por supuesto, p5 ofrece muchas m\u00e1s funciones y variables para dibujar otras figuras, trabajar con colores o leer otros perif\u00e9ricos. Pero por muy complicados que los hagamos, todos los programas de p5 tienen exactamente la misma estructura: import , setup() , draw() y run() . \u00a1Es muy f\u00e1cil!","title":"Hola mundo, vesi\u00f3n p5"},{"location":"#coordenadas","text":"Para dibujar en Processing se har\u00e1 un uso frecuente de las coordenadas de la ventana. Su tama\u00f1o se define en la funci\u00f3n setup() mediante size(ancho,largo) . Para dibujar, debemos tener en cuenta que el punto x = 0, y = 0 est\u00e1 situado en la esquina superior derecha. x,y x,y x,y (0,0) (1,0) (2,0) (0,1) (1,1) (2,1) (0,2) (1,2) (2,2) En p5, podemos conocer el ancho y largo de la ventana actual, definidos en size, mediante dos variables globales. height . Ancho de la ventana. width . Largo de la ventana. As\u00ed, para dibujar una l\u00ednea desde el centro de la ventana a all\u00e1 donde est\u00e9 el cursor del rat\u00f3n har\u00edamos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 from p5 import * # Usar funciones de p5 def setup (): # Inicializaci\u00f3n size ( 300 , 300 ) # Define tama\u00f1o de la ventana stroke ( 0 , 0 , 0 ) # Trazo negro def draw (): # Dibujar background ( 255 , 255 , 255 ) # Fondo blanco centro_x = height / 2 # Calcula mitad de la ventana centro_y = width / 2 # Calcula mitad de la ventana line ( centro_x , # Dibujar l\u00ednea desde el centro centro_y , # de la ventana hasta cursor rat\u00f3n. mouse_x , # Coordenada x del rat\u00f3n mouse_y ) # Coordenada y del rat\u00f3n run () # Ejecutar programa El programa es bastante similar al anterior, pero en este caso, las coordenadas del centro de la ventana se calculan autom\u00e1ticamente.","title":"Coordenadas"},{"location":"#colores","text":"A la hora de dibujar, muchas veces deberemos especificar un color. Aunque no sea expl\u00edcito, las figuras necesitan al menos el color del trazo, pero muchas veces tambi\u00e9n el relleno. Y hay varias formas de especificar los colores. Escala de gris, de 0 a 255 . Representa un color en la escala de grises, desde el negro (0) al blanco (255). Rojo, verde, azul . En este caso, indicamos tres valores, tambi\u00e9n desde el 0 al 255, pero indicando el tono de rojo, verde y azul. Rojo, verde, azul, transparencia . Opcionalmente, podemos indicar un cuarto valor, el de la transparencia, tambi\u00e9n desde 0 (completamente transparente) a 255 (opaco). Esto nos permite combinar figuras y mezclar colores. Veamos algunos ejemplos de uso: 1 2 3 background ( 255 ) # Fondo blanco background ( 255 , 0 , 0 ) # Fondo rojo background ( 0 , 0 , 255 , 127 ) # Fondo azul, semi-transparente Antes dibujamos una l\u00ednea, \u00bfd\u00f3nde especifiacamos el color de su trazo? Hay dos funciones que debemos llamar antes para indicar los colores tanto el trazo como del relleno de las figuras. stroke(color) . Define el color del trazo. no_stroke() . Dibuja la figura sin trazos. fill(color) . Relleno de la figura. Se aplica en cuadrados, rect\u00e1ngulos o elipses. no_fill() . Dibuja la figura sin color de relleno. Por ejemplo, para dibujar un rect\u00e1ngulo con trazo blanco y relleno verde: 1 2 3 stroke ( 255 ) # Trazo blanco fill ( 0 , 255 , 0 ) # Relleno verde rect ( 25 , 25 , 75 , 75 ) # Dibujar rect\u00e1ngulo Estas funciones se pueden encadenar para dibujar varias figuras con diferentes colores. 1 2 3 4 5 stroke ( 127 , 5 , 38 ) # Trazo de color no_fill () # Sin relleno rect ( 10 , 10 , 90 , 90 ) # Dibujar rect\u00e1ngulo fill ( 255 , 0 , 0 , 127 ) # Relleno rojo semi-transparente rect ( 20 , 20 , 80 , 80 ) # Otro rect\u00e1ngulo","title":"Colores"},{"location":"#figuras-basicas","text":"Bueno, aunque ya hemos visto c\u00f3mo usar dos figuras en p5, vamos a poner aqu\u00ed otras m\u00e1s: point(x,y) . Dibuja un punto con el trazo especificado por stroke() . line(x_inicial, y_inicial, x_final, y_final) . Dibuja una l\u00ednea desde las coordenadas iniciales a las coordenadas finales. Usa el color de trazo especificado por stroke() . triangle(x_1, y_1, x_2, y_2, x_3, y_3) . Dibuja un tri\u00e1ngulo definido por tres coordenadas. Color de trazo especificado por stroke() y relleno por fill() . square(x, y, lado) . Dibuja un cuadrado de tama\u00f1o lado en las coordenadas indicadas. Color de trazo especificado por stroke() y relleno por fill() . rect(x, y, largo, ancho) . Dibuja un rect\u00e1ngulo desde las coordenadas iniciales a las coordenadas. Color de trazo especificado por stroke() y relleno por fill() . circle(x, y, radio) . Dibuja un c\u00edrculo con centro en las coordenadas x,y y con el radio especificado. Color de trazo especificado por stroke() y relleno por fill() . ellipse(x, y, largo, ancho) . Dibuja una elipse con centro en las coordenadas x,y y con el ancho y largo especificados. Color de trazo especificado por stroke() y relleno por fill() . Todos los par\u00e1metros indicados (coordenadas, radios, tama\u00f1os) son num\u00e9ricos, generalmente n\u00fameros naturales.","title":"Figuras b\u00e1sicas"},{"location":"#textos","text":"Processing, y p5, tambi\u00e9n permiten escribir textos. Para ello se usa la funci\u00f3n text() . text(texto, x, y) . Escribe el texto en las coordenadas x,y con el color de trazo especificado por stroke() . Tambi\u00e9n es posibile indicar el tama\u00f1o. text_size(tama\u00f1o) . Cambiar el tama\u00f1o del texto, medido en p\u00edxeles. Actualmente, para usar la funci\u00f3n text_size() , p5 requiere usar una fuente vectorial. Uno de los formatos m\u00e1s populares para tipograf\u00edas vectoriales es TTF (TrueType Font) y los sistemas operativos suelen venir con estos ficheros. Adem\u00e1s, hay fuentes libres de derechos que se pueden descargar desde Internet. En nuestro ejemplo, usamos una fuente disponible en Linux. create_font(fichero) . Fichero debe ser la ruta y el nombre del fichero con la tipograf\u00eda vectorial a utilizar. Devuelve un valor de tipo PFont (fuente de Processing). Este valor hay que usarlo para establecer la fuente predefinida. text_font(fuente) . Establece la fuente por defecto. El par\u00e1metro fuente debe ser del tipo PFont. Ahora veamos un ejemplo de uso de textos: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 from p5 import * # Usar funciones de p5 def setup (): # Inicializaci\u00f3n size ( 300 , 300 ) # Establecer tama\u00f1o de la ventana fuente = create_font ( 'DejaVuSans.ttf' ) # Usar fuente text_font ( fuente ) # Esteblecer fuente predefinida def draw (): background ( 0 ) # Fondo negro stroke ( 255 ) # Trazo blanco text_size ( 20 ) # Tama\u00f1o de texto text ( \"Hola mundo\" , 0 , 0 ) # Escribe texto run () # Ejecutar programa","title":"Textos"},{"location":"#interaccion","text":"Para reaccionar a acciones realizadas por los usuarios, los programas con interfaz gr\u00e1fico deben leer los estados y eventos del teclado y rat\u00f3n. p5 no es menos, y lo hace bastante sencillo.","title":"Interacci\u00f3n"},{"location":"#raton","text":"Como hemos visto, podemos conocer las coordenadas del rat\u00f3n, pero no son las \u00fanicas variables disponibles. Tambi\u00e9n es posible detectar si se han pulsado los botones: mouse_x . Coordenada x del rat\u00f3n. mouse_y . Coordenada y del rat\u00f3n. mouse_is_pressed . Verdadero si se ha pulsado un bot\u00f3n del rat\u00f3n. mouse_button . Si mouse_is_pressed es verdadero, mouse_button tendr\u00e1 el valor LEFT o RIGHT seg\u00fan el bot\u00f3n del rat\u00f3n que se ha presionado (izquierdo, derecho). Vamos a ver c\u00f3mo cambiar el fondo de la pantalla seg\u00fan est\u00e9 pulsado o no el bot\u00f3n del rat\u00f3n. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from p5 import * # Usar funciones de p5 def setup (): size ( 300 , 300 ) # Tama\u00f1o de la ventana def draw (): if mouse_is_pressed == True : # Si se ha presionado el bot\u00f3n del rat\u00f3n if mouse_button == 'LEFT' : # y el bot\u00f3n es el izquierdo background ( 255 ) # mostrar el fondo en blanco else : # pero si es el bot\u00f3n derech background ( 127 ) # mostrar el fondo en gris. else : # Si no se ha presionado el rat\u00f3n background ( 0 ) # mostrar el fondo de color negro. run () # Ejecutar programa","title":"Rat\u00f3n"},{"location":"#teclado","text":"La l\u00f3gica del teclado es similar a la del rat\u00f3n. Hay funciones para saber si se ha pulsado alguna tecla y otra para saber qu\u00e9 tecla ha sido. key_is_pressed . Es verdadero si hay una tecla pulsada. key . Da el valor de la tecla. Si son caracteres normales, nos da su valor (por ejemplo a , '\u00d1' o \u20ac ). Pero tambi\u00e9n nos indica si se ha pulsado alguna tecla especial. Los valores de teclas especiales son: UP (flecha arriba), DOWN (flecha abajo), LEFT (flecha izquierda), RIGHT (flecha derecha), PAGEUP (p\u00e1gina arriba), PAGEDOWN (p\u00e1gina abajo), RETURN (retorno), ENTER , ESC (escape), DELETE (suprimir), TAB (tabulador), BACKSPACE (borrar), SHIFT (may\u00fascula), ALT , CONTROL , F1 ... F12 (teclas de funci\u00f3n), HOME (inicio), END (fin). Vamos a dibujar por la pantalla usando las flechas del teclado: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from p5 import * # Usar funciones de p5 cursor_x = 0 # Variables globales para almacenar cursor_y = 0 # la posici\u00f3n actual del cursor camino = [] # Lista para camino recorrido def setup (): # Inicializaci\u00f3n global cursor_x , cursor_y # Usar las variables globales size ( 300 , 300 ) # Tama\u00f1o de la ventana cursor_x = height / 2 # Posici\u00f3n inicial para comenzar cursor_y = width / 2 # a pintar: centro de ventana stroke ( 0 ) # Trazo negro def draw (): # Dibujar global cursor_x , cursor_y # Usar las variables globales global camino # Usar las variables globales background ( 255 ) # Aqu\u00ed para no borrar la ventana if key_is_pressed == True : # \u00bfSe ha presionado una tecla? pos = ( cursor_x , cursor_y ) # Almacenar posici\u00f3n actual en tupla camino . append ( pos ) # Guardar tupla en lista print ( len ( camino )) if key == 'LEFT' : # Flecha izquierda cursor_x = cursor_x - 1 # ir a la izquierda elif key == 'RIGHT' : # Flecha derecha cursor_x = cursor_x + 1 # ir a la derecha elif key == 'UP' : # Flecha arriba cursor_y = cursor_y - 1 # ir arriba elif key == 'DOWN' : # Flecha abajo cursor_y = cursor_y + 1 # ir abajo for punto in camino : # Dibujar camino ya realizado x = punto [ 0 ] # Obtener coordenada x del punto y = punto [ 1 ] # Obtener coordenada y del punto point ( x , y ) # Dibujar punto point ( cursor_x , cursor_y ) # Dibujar punto en posici\u00f3n actual run ()","title":"Teclado"},{"location":"#como-instalar-p5-en-linux","text":"","title":"C\u00f3mo instalar p5 en Linux"},{"location":"#debian-ubuntu-raspberry-pi-os","text":"De momento, p5py no est\u00e1 empaquetado en Debian, lo que significa que tampoco est\u00e1 disponible en las distribuciones derivadas como Ubuntu y Raspberry Pi OS. Lo primero que hay que hacer es asegurarse de que el paquete python3-pil no est\u00e1 instalado, dado que entra en conflicto con otras librer\u00edas que p5 necesita instalar. 1 $ sudo apt-get remove python3-pil <!-- Los siguientes paquetes se ELIMINAR\u00c1N: hplip mu-editor python3-guizero python3-pil python3-pil.imagetk python3-reportlab python3-sense-emu python3-sense-hat sense-emu-tools sense-hat libf77blas.so.3: cannot open shared file: no such file or directory sudo apt-get install libatlas-base-dev RuntimeError: Could not import backend \"Glfw\" sudo apt install libglfw3 OpenGL.error.NullFunctionError: Attempt to call an undefined function gluNewTess, check for bool(gluNewTess) before calling apt-get install freeglut3-dev --> A continuaci\u00f3n, instalamos algunas librer\u00edas necesarias: 1 2 $ sudo apt-get install libjpeg-dev libfreetype6 libfreetype6-dev \\ zlib1g-dev libatlas-base-dev libglfw3 freeglut3-dev Y finalmente, instalamos p5: 1 $ pip3 install p5","title":"Debian, Ubuntu, Raspberry Pi OS"},{"location":"#fedora","text":"Primero hay que instalar las dependencias 1 $ sudo dnf install glfw Y finalmente, instalamos p5: 1 $ pip3 install p5","title":"Fedora"},{"location":"#problemas-conocidos","text":"Processing, el original, es un proyecto maduro mientras que p5 a\u00fan est\u00e1 en desarrollo activo. Algunos de los problemas que he encontrado hasta ahora son: Para finalizar la ejecuci\u00f3n de un programa de p5 en Thonny, tras cerrar la ventana hay que parar la ejecuci\u00f3n de la tarea de forma manual. Algo similar ocurre en Python IDLE y probablemente en otros entornos integrados. Actualmente no se puede modificar el tama\u00f1o del tipo de letra predefinida, hay que usar una tipograf\u00eda vectorial. Las funciones de dibujo no se ejecutan en setup() , solo en draw() . En el ejemplo de uso del teclado, las llamadas a point() en el bucle son muy lentas. Eso hace que el retardo en responder al teclado se vaya acumulando seg\u00fan hay m\u00e1s puntos.","title":"Problemas conocidos"},{"location":"#conclusiones","text":"p5 ofrece unas librer\u00edas gr\u00e1ficas reconocidas por su facilidad de uso. Sin embargo, su versi\u00f3n actual (0.7.3) no est\u00e1 exenta de peque\u00f1os problemas y no ofrece el mismo rendimiento que Processing en otros lenguajes, como Java o JavaScript. Es posible que en futuras versiones estos problemas se arreglen y la experiencia de uso sea mucho m\u00e1s satisfactoria.","title":"Conclusiones"},{"location":"#enlaces","text":"Documentaci\u00f3n de p5 . Referencia de funciones . P\u00e1gina de desarrollo de p5 . Processing . Tutorial de Python .","title":"Enlaces"}]}